use af_sui_types::Address as SuiAddress;
use futures_core::Stream;

use super::fragments::MoveValueRaw;
use super::outputs::{DynamicField as OutputDf, ObjectKey, RawMoveValue};
use super::{Error, fragments, stream};
use crate::{GraphQlClient, GraphQlResponseExt as _, missing_data, schema};

pub async fn query<C: GraphQlClient>(
    client: &C,
    address: SuiAddress,
    root_version: Option<u64>,
    page_size: Option<i32>,
) -> impl Stream<Item = super::Result<(RawMoveValue, OutputDf), C>> + '_ {
    let vars = QueryVariables {
        address,
        root_version,
        first: page_size,
        after: None,
    };

    stream::forward(client, vars, request)
}

async fn request<C: GraphQlClient>(
    client: &C,
    vars: QueryVariables,
) -> super::Result<
    stream::Page<
        impl Iterator<Item = super::Result<(RawMoveValue, OutputDf), C>> + 'static + use<C>,
    >,
    C,
> {
    let data = client
        .query::<Query, _>(vars)
        .await
        .map_err(Error::Client)?
        .try_into_data()?
        .ok_or(missing_data!("Response empty"))?;

    let DynamicFieldConnection { nodes, page_info } = data
        .owner
        .ok_or(missing_data!("No owner found"))?
        .dynamic_fields;

    let data = nodes.into_iter().map(|DynamicField { name, value }| {
        let name = name
            .ok_or(missing_data!("Dynamic field found but with no name"))?
            .into();
        let instance = value.ok_or(missing_data!("Dynamic field found but with no value"))?;
        let out = match instance {
            DynamicFieldValue::MoveObject(MoveObject {
                object_id,
                version,
                contents,
            }) => {
                let struct_ = contents
                    .ok_or(missing_data!("No contents for DOF"))?
                    .try_into()
                    .expect("Only Move structs can be top-level objects");
                OutputDf::Object(ObjectKey { object_id, version }, struct_)
            }
            DynamicFieldValue::MoveValue(value) => OutputDf::Field(value.into()),
            DynamicFieldValue::Unknown => return Err(missing_data!("Unknown dynamic field type")),
        };
        Ok((name, out))
    });

    Ok(stream::Page {
        info: page_info,
        data,
    })
}

#[cfg(test)]
#[allow(clippy::unwrap_used)]
#[test]
fn gql_output() {
    use cynic::QueryBuilder as _;
    let vars = QueryVariables {
        address: SuiAddress::new(rand::random()),
        root_version: None,
        first: None,
        after: None,
    };
    let operation = Query::build(vars);
    insta::assert_snapshot!(operation.query, @r###"
     query Query($address: SuiAddress!, $rootVersion: UInt53, $after: String, $first: Int) {
       owner(address: $address, rootVersion: $rootVersion) {
         dynamicFields(first: $first, after: $after) {
           nodes {
             name {
               type {
                 repr
               }
               bcs
             }
             value {
               __typename
               ... on MoveObject {
                 address
                 version
                 contents {
                   type {
                     repr
                   }
                   bcs
                 }
               }
               ... on MoveValue {
                 type {
                   repr
                 }
                 bcs
               }
             }
           }
           pageInfo {
             hasNextPage
             endCursor
             hasPreviousPage
             startCursor
           }
         }
       }
     }
     "###);
}

// ================================================================================
//  Mostly autogenerated by: https://generator.cynic-rs.dev/
// ================================================================================

#[derive(cynic::QueryVariables, Debug, Clone)]
struct QueryVariables {
    address: SuiAddress,
    root_version: Option<af_sui_types::Version>,
    after: Option<String>,
    first: Option<i32>,
}

impl stream::UpdatePageInfo for QueryVariables {
    fn update_page_info(&mut self, info: &fragments::PageInfo) {
        self.after.clone_from(&info.end_cursor)
    }
}

#[derive(cynic::QueryFragment, Debug)]
#[cynic(variables = "QueryVariables")]
struct Query {
    #[arguments(address: $address, rootVersion: $root_version)]
    owner: Option<Owner>,
}

#[derive(cynic::QueryFragment, Debug)]
#[cynic(variables = "QueryVariables")]
struct Owner {
    #[arguments(first: $first, after: $after)]
    dynamic_fields: DynamicFieldConnection,
}

#[derive(cynic::QueryFragment, Debug)]
struct MoveObject {
    #[cynic(rename = "address")]
    object_id: SuiAddress,
    version: af_sui_types::Version,
    contents: Option<MoveValueRaw>,
}

#[derive(cynic::QueryFragment, Debug)]
struct DynamicFieldConnection {
    nodes: Vec<DynamicField>,
    page_info: fragments::PageInfo,
}

#[derive(cynic::QueryFragment, Debug)]
struct DynamicField {
    name: Option<MoveValueRaw>,
    value: Option<DynamicFieldValue>,
}

#[derive(cynic::InlineFragments, Debug)]
enum DynamicFieldValue {
    MoveObject(MoveObject),
    MoveValue(MoveValueRaw),
    #[cynic(fallback)]
    Unknown,
}
